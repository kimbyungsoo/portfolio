'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeHiddenProperties = removeHiddenProperties;
exports.verifyCredentials = verifyCredentials;
exports.logIn = logIn;

var _password = require('./password');

var _password2 = _interopRequireDefault(_password);

var _AccountLockout = require('./AccountLockout');

var _AccountLockout2 = _interopRequireDefault(_AccountLockout);

var _Auth = require('./Auth');

var _Auth2 = _interopRequireDefault(_Auth);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const Parse = require('parse/node');
function removeHiddenProperties(obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      // Regexp comes from Parse.Object.prototype.validate
      if (key !== "__type" && !/^[A-Za-z][0-9A-Za-z_]*$/.test(key)) {
        delete obj[key];
      }
    }
  }
}

async function verifyCredentials({ username, password, email }, config, auth) {
  // TODO: use the right error codes / descriptions.
  if (!username && !email) {
    throw new Parse.Error(Parse.Error.USERNAME_MISSING, 'username/email is required.');
  }
  if (!password) {
    throw new Parse.Error(Parse.Error.PASSWORD_MISSING, 'password is required.');
  }
  if (typeof password !== 'string' || email && typeof email !== 'string' || username && typeof username !== 'string') {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Invalid username/password.');
  }

  let user;
  let isValidPassword = false;
  let query;
  if (email && username) {
    query = { email, username };
  } else if (email) {
    query = { email };
  } else {
    query = { $or: [{ username }, { email: username }] };
  }
  const results = await config.database.find('_User', query);
  if (!results.length) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Invalid username/password.');
  }

  if (results.length > 1) {
    // corner case where user1 has username == user2 email
    config.loggerController.warn('There is a user which email is the same as another user\'s username, logging in based on username');
    user = results.filter(user => user.username === username)[0];
  } else {
    user = results[0];
  }

  isValidPassword = await _password2.default.compare(password, user.password);
  const accountLockoutPolicy = new _AccountLockout2.default(user, config);
  await accountLockoutPolicy.handleLoginAttempt(isValidPassword);
  if (!isValidPassword) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Invalid username/password.');
  }
  // Ensure the user isn't locked out
  // A locked out user won't be able to login
  // To lock a user out, just set the ACL to `masterKey` only  ({}).
  // Empty ACL is OK
  if (!auth.isMaster && user.ACL && Object.keys(user.ACL).length == 0) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Invalid username/password.');
  }
  if (config.verifyUserEmails && config.preventLoginWithUnverifiedEmail && !user.emailVerified) {
    throw new Parse.Error(Parse.Error.EMAIL_NOT_FOUND, 'User email is not verified.');
  }

  delete user.password;

  // Sometimes the authData still has null on that keys
  // https://github.com/parse-community/parse-server/issues/935
  if (user.authData) {
    Object.keys(user.authData).forEach(provider => {
      if (user.authData[provider] === null) {
        delete user.authData[provider];
      }
    });
    if (Object.keys(user.authData).length == 0) {
      delete user.authData;
    }
  }

  return user;
}

async function logIn({ username, password, email }, config, auth, installationId) {
  const user = await verifyCredentials({ username, password, email }, config, auth);
  // handle password expiry policy
  if (config.passwordPolicy && config.passwordPolicy.maxPasswordAge) {
    let changedAt = user._password_changed_at;

    if (!changedAt) {
      // password was created before expiry policy was enabled.
      // simply update _User object so that it will start enforcing from now
      changedAt = new Date();
      config.database.update('_User', { username: user.username }, { _password_changed_at: Parse._encode(changedAt) });
    } else {
      // check whether the password has expired
      if (changedAt.__type == 'Date') {
        changedAt = new Date(changedAt.iso);
      }
      // Calculate the expiry time.
      const expiresAt = new Date(changedAt.getTime() + 86400000 * config.passwordPolicy.maxPasswordAge);
      if (expiresAt < new Date()) // fail of current time is past password expiry time
        throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Your password has expired. Please reset your password.');
    }
  }

  // Remove hidden properties.
  removeHiddenProperties(user);

  const {
    sessionData,
    createSession
  } = _Auth2.default.createSession(config, {
    userId: user.objectId, createdWith: {
      'action': 'login',
      'authProvider': 'password'
    }, installationId: installationId
  });

  user.sessionToken = sessionData.sessionToken;

  config.filesController.expandFilesInObject(config, user);

  await createSession();
  return user;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9Vc2VyQXV0aGVudGljYXRpb24uanMiXSwibmFtZXMiOlsicmVtb3ZlSGlkZGVuUHJvcGVydGllcyIsInZlcmlmeUNyZWRlbnRpYWxzIiwibG9nSW4iLCJQYXJzZSIsInJlcXVpcmUiLCJvYmoiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsInRlc3QiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiZW1haWwiLCJjb25maWciLCJhdXRoIiwiRXJyb3IiLCJVU0VSTkFNRV9NSVNTSU5HIiwiUEFTU1dPUkRfTUlTU0lORyIsIk9CSkVDVF9OT1RfRk9VTkQiLCJ1c2VyIiwiaXNWYWxpZFBhc3N3b3JkIiwicXVlcnkiLCIkb3IiLCJyZXN1bHRzIiwiZGF0YWJhc2UiLCJmaW5kIiwibGVuZ3RoIiwibG9nZ2VyQ29udHJvbGxlciIsIndhcm4iLCJmaWx0ZXIiLCJwYXNzd29yZENyeXB0byIsImNvbXBhcmUiLCJhY2NvdW50TG9ja291dFBvbGljeSIsIkFjY291bnRMb2Nrb3V0IiwiaGFuZGxlTG9naW5BdHRlbXB0IiwiaXNNYXN0ZXIiLCJBQ0wiLCJPYmplY3QiLCJrZXlzIiwidmVyaWZ5VXNlckVtYWlscyIsInByZXZlbnRMb2dpbldpdGhVbnZlcmlmaWVkRW1haWwiLCJlbWFpbFZlcmlmaWVkIiwiRU1BSUxfTk9UX0ZPVU5EIiwiYXV0aERhdGEiLCJmb3JFYWNoIiwicHJvdmlkZXIiLCJpbnN0YWxsYXRpb25JZCIsInBhc3N3b3JkUG9saWN5IiwibWF4UGFzc3dvcmRBZ2UiLCJjaGFuZ2VkQXQiLCJfcGFzc3dvcmRfY2hhbmdlZF9hdCIsIkRhdGUiLCJ1cGRhdGUiLCJfZW5jb2RlIiwiX190eXBlIiwiaXNvIiwiZXhwaXJlc0F0IiwiZ2V0VGltZSIsInNlc3Npb25EYXRhIiwiY3JlYXRlU2Vzc2lvbiIsIkF1dGgiLCJ1c2VySWQiLCJvYmplY3RJZCIsImNyZWF0ZWRXaXRoIiwic2Vzc2lvblRva2VuIiwiZmlsZXNDb250cm9sbGVyIiwiZXhwYW5kRmlsZXNJ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QW5CLEVBQTJCO0FBQzdCZ0QsWUFBUTFDLEtBQUsyQyxRQURnQixFQUNOQyxhQUFhO0FBQ2xDLGdCQUFVLE9BRHdCO0FBRWxDLHNCQUFnQjtBQUZrQixLQURQLEVBSTFCakIsZ0JBQWdCQTtBQUpVLEdBQTNCLENBSEo7O0FBVUEzQixPQUFLNkMsWUFBTCxHQUFvQk4sWUFBWU0sWUFBaEM7O0FBRUFuRCxTQUFPb0QsZUFBUCxDQUF1QkMsbUJBQXZCLENBQTJDckQsTUFBM0MsRUFBbURNLElBQW5EOztBQUVBLFFBQU13QyxlQUFOO0FBQ0EsU0FBT3hDLElBQVA7QUFDRCIsImZpbGUiOiJVc2VyQXV0aGVudGljYXRpb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBQYXJzZSA9IHJlcXVpcmUoJ3BhcnNlL25vZGUnKTtcbmltcG9ydCBwYXNzd29yZENyeXB0byBmcm9tICcuL3Bhc3N3b3JkJztcbmltcG9ydCBBY2NvdW50TG9ja291dCBmcm9tICcuL0FjY291bnRMb2Nrb3V0JztcbmltcG9ydCBBdXRoIGZyb20gJy4vQXV0aCc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVIaWRkZW5Qcm9wZXJ0aWVzKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAvLyBSZWdleHAgY29tZXMgZnJvbSBQYXJzZS5PYmplY3QucHJvdG90eXBlLnZhbGlkYXRlXG4gICAgICBpZiAoa2V5ICE9PSBcIl9fdHlwZVwiICYmICEoL15bQS1aYS16XVswLTlBLVphLXpfXSokLykudGVzdChrZXkpKSB7XG4gICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcmlmeUNyZWRlbnRpYWxzKHsgdXNlcm5hbWUsIHBhc3N3b3JkLCBlbWFpbCB9LCBjb25maWcsIGF1dGgpIHtcbiAgLy8gVE9ETzogdXNlIHRoZSByaWdodCBlcnJvciBjb2RlcyAvIGRlc2NyaXB0aW9ucy5cbiAgaWYgKCF1c2VybmFtZSAmJiAhZW1haWwpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuVVNFUk5BTUVfTUlTU0lORywgJ3VzZXJuYW1lL2VtYWlsIGlzIHJlcXVpcmVkLicpO1xuICB9XG4gIGlmICghcGFzc3dvcmQpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuUEFTU1dPUkRfTUlTU0lORywgJ3Bhc3N3b3JkIGlzIHJlcXVpcmVkLicpO1xuICB9XG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICdzdHJpbmcnXG4gICAgfHwgZW1haWwgJiYgdHlwZW9mIGVtYWlsICE9PSAnc3RyaW5nJ1xuICAgIHx8IHVzZXJuYW1lICYmIHR5cGVvZiB1c2VybmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCwgJ0ludmFsaWQgdXNlcm5hbWUvcGFzc3dvcmQuJyk7XG4gIH1cblxuICBsZXQgdXNlcjtcbiAgbGV0IGlzVmFsaWRQYXNzd29yZCA9IGZhbHNlO1xuICBsZXQgcXVlcnk7XG4gIGlmIChlbWFpbCAmJiB1c2VybmFtZSkge1xuICAgIHF1ZXJ5ID0geyBlbWFpbCwgdXNlcm5hbWUgfTtcbiAgfSBlbHNlIGlmIChlbWFpbCkge1xuICAgIHF1ZXJ5ID0geyBlbWFpbCB9O1xuICB9IGVsc2Uge1xuICAgIHF1ZXJ5ID0geyAkb3I6IFt7IHVzZXJuYW1lIH0sIHsgZW1haWw6IHVzZXJuYW1lIH1dIH07XG4gIH1cbiAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNvbmZpZy5kYXRhYmFzZS5maW5kKCdfVXNlcicsIHF1ZXJ5KTtcbiAgaWYgKCFyZXN1bHRzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5PQkpFQ1RfTk9UX0ZPVU5ELCAnSW52YWxpZCB1c2VybmFtZS9wYXNzd29yZC4nKTtcbiAgfVxuXG4gIGlmIChyZXN1bHRzLmxlbmd0aCA+IDEpIHsgLy8gY29ybmVyIGNhc2Ugd2hlcmUgdXNlcjEgaGFzIHVzZXJuYW1lID09IHVzZXIyIGVtYWlsXG4gICAgY29uZmlnLmxvZ2dlckNvbnRyb2xsZXIud2FybignVGhlcmUgaXMgYSB1c2VyIHdoaWNoIGVtYWlsIGlzIHRoZSBzYW1lIGFzIGFub3RoZXIgdXNlclxcJ3MgdXNlcm5hbWUsIGxvZ2dpbmcgaW4gYmFzZWQgb24gdXNlcm5hbWUnKTtcbiAgICB1c2VyID0gcmVzdWx0cy5maWx0ZXIoKHVzZXIpID0+IHVzZXIudXNlcm5hbWUgPT09IHVzZXJuYW1lKVswXTtcbiAgfSBlbHNlIHtcbiAgICB1c2VyID0gcmVzdWx0c1swXTtcbiAgfVxuXG4gIGlzVmFsaWRQYXNzd29yZCA9IGF3YWl0IHBhc3N3b3JkQ3J5cHRvLmNvbXBhcmUocGFzc3dvcmQsIHVzZXIucGFzc3dvcmQpO1xuICBjb25zdCBhY2NvdW50TG9ja291dFBvbGljeSA9IG5ldyBBY2NvdW50TG9ja291dCh1c2VyLCBjb25maWcpO1xuICBhd2FpdCBhY2NvdW50TG9ja291dFBvbGljeS5oYW5kbGVMb2dpbkF0dGVtcHQoaXNWYWxpZFBhc3N3b3JkKTtcbiAgaWYgKCFpc1ZhbGlkUGFzc3dvcmQpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCwgJ0ludmFsaWQgdXNlcm5hbWUvcGFzc3dvcmQuJyk7XG4gIH1cbiAgLy8gRW5zdXJlIHRoZSB1c2VyIGlzbid0IGxvY2tlZCBvdXRcbiAgLy8gQSBsb2NrZWQgb3V0IHVzZXIgd29uJ3QgYmUgYWJsZSB0byBsb2dpblxuICAvLyBUbyBsb2NrIGEgdXNlciBvdXQsIGp1c3Qgc2V0IHRoZSBBQ0wgdG8gYG1hc3RlcktleWAgb25seSAgKHt9KS5cbiAgLy8gRW1wdHkgQUNMIGlzIE9LXG4gIGlmICghYXV0aC5pc01hc3RlciAmJiB1c2VyLkFDTCAmJiBPYmplY3Qua2V5cyh1c2VyLkFDTCkubGVuZ3RoID09IDApIHtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCwgJ0ludmFsaWQgdXNlcm5hbWUvcGFzc3dvcmQuJyk7XG4gIH1cbiAgaWYgKGNvbmZpZy52ZXJpZnlVc2VyRW1haWxzICYmIGNvbmZpZy5wcmV2ZW50TG9naW5XaXRoVW52ZXJpZmllZEVtYWlsICYmICF1c2VyLmVtYWlsVmVyaWZpZWQpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuRU1BSUxfTk9UX0ZPVU5ELCAnVXNlciBlbWFpbCBpcyBub3QgdmVyaWZpZWQuJyk7XG4gIH1cblxuICBkZWxldGUgdXNlci5wYXNzd29yZDtcblxuICAvLyBTb21ldGltZXMgdGhlIGF1dGhEYXRhIHN0aWxsIGhhcyBudWxsIG9uIHRoYXQga2V5c1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGFyc2UtY29tbXVuaXR5L3BhcnNlLXNlcnZlci9pc3N1ZXMvOTM1XG4gIGlmICh1c2VyLmF1dGhEYXRhKSB7XG4gICAgT2JqZWN0LmtleXModXNlci5hdXRoRGF0YSkuZm9yRWFjaCgocHJvdmlkZXIpID0+IHtcbiAgICAgIGlmICh1c2VyLmF1dGhEYXRhW3Byb3ZpZGVyXSA9PT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgdXNlci5hdXRoRGF0YVtwcm92aWRlcl07XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKE9iamVjdC5rZXlzKHVzZXIuYXV0aERhdGEpLmxlbmd0aCA9PSAwKSB7XG4gICAgICBkZWxldGUgdXNlci5hdXRoRGF0YTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdXNlcjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvZ0luKHsgdXNlcm5hbWUsIHBhc3N3b3JkLCBlbWFpbCB9LCBjb25maWcsIGF1dGgsIGluc3RhbGxhdGlvbklkKSB7XG4gIGNvbnN0IHVzZXIgPSBhd2FpdCB2ZXJpZnlDcmVkZW50aWFscyh7IHVzZXJuYW1lLCBwYXNzd29yZCwgZW1haWwgfSwgY29uZmlnLCBhdXRoKTtcbiAgLy8gaGFuZGxlIHBhc3N3b3JkIGV4cGlyeSBwb2xpY3lcbiAgaWYgKGNvbmZpZy5wYXNzd29yZFBvbGljeSAmJiBjb25maWcucGFzc3dvcmRQb2xpY3kubWF4UGFzc3dvcmRBZ2UpIHtcbiAgICBsZXQgY2hhbmdlZEF0ID0gdXNlci5fcGFzc3dvcmRfY2hhbmdlZF9hdDtcblxuICAgIGlmICghY2hhbmdlZEF0KSB7XG4gICAgICAvLyBwYXNzd29yZCB3YXMgY3JlYXRlZCBiZWZvcmUgZXhwaXJ5IHBvbGljeSB3YXMgZW5hYmxlZC5cbiAgICAgIC8vIHNpbXBseSB1cGRhdGUgX1VzZXIgb2JqZWN0IHNvIHRoYXQgaXQgd2lsbCBzdGFydCBlbmZvcmNpbmcgZnJvbSBub3dcbiAgICAgIGNoYW5nZWRBdCA9IG5ldyBEYXRlKCk7XG4gICAgICBjb25maWcuZGF0YWJhc2UudXBkYXRlKCdfVXNlcicsIHsgdXNlcm5hbWU6IHVzZXIudXNlcm5hbWUgfSxcbiAgICAgICAgeyBfcGFzc3dvcmRfY2hhbmdlZF9hdDogUGFyc2UuX2VuY29kZShjaGFuZ2VkQXQpIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBwYXNzd29yZCBoYXMgZXhwaXJlZFxuICAgICAgaWYgKGNoYW5nZWRBdC5fX3R5cGUgPT0gJ0RhdGUnKSB7XG4gICAgICAgIGNoYW5nZWRBdCA9IG5ldyBEYXRlKGNoYW5nZWRBdC5pc28pO1xuICAgICAgfVxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBleHBpcnkgdGltZS5cbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IG5ldyBEYXRlKGNoYW5nZWRBdC5nZXRUaW1lKCkgKyA4NjQwMDAwMCAqIGNvbmZpZy5wYXNzd29yZFBvbGljeS5tYXhQYXNzd29yZEFnZSk7XG4gICAgICBpZiAoZXhwaXJlc0F0IDwgbmV3IERhdGUoKSkgLy8gZmFpbCBvZiBjdXJyZW50IHRpbWUgaXMgcGFzdCBwYXNzd29yZCBleHBpcnkgdGltZVxuICAgICAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCwgJ1lvdXIgcGFzc3dvcmQgaGFzIGV4cGlyZWQuIFBsZWFzZSByZXNldCB5b3VyIHBhc3N3b3JkLicpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBoaWRkZW4gcHJvcGVydGllcy5cbiAgcmVtb3ZlSGlkZGVuUHJvcGVydGllcyh1c2VyKTtcblxuICBjb25zdCB7XG4gICAgc2Vzc2lvbkRhdGEsXG4gICAgY3JlYXRlU2Vzc2lvblxuICB9ID0gQXV0aC5jcmVhdGVTZXNzaW9uKGNvbmZpZywge1xuICAgIHVzZXJJZDogdXNlci5vYmplY3RJZCwgY3JlYXRlZFdpdGg6IHtcbiAgICAgICdhY3Rpb24nOiAnbG9naW4nLFxuICAgICAgJ2F1dGhQcm92aWRlcic6ICdwYXNzd29yZCdcbiAgICB9LCBpbnN0YWxsYXRpb25JZDogaW5zdGFsbGF0aW9uSWRcbiAgfSk7XG5cbiAgdXNlci5zZXNzaW9uVG9rZW4gPSBzZXNzaW9uRGF0YS5zZXNzaW9uVG9rZW47XG5cbiAgY29uZmlnLmZpbGVzQ29udHJvbGxlci5leHBhbmRGaWxlc0luT2JqZWN0KGNvbmZpZywgdXNlcik7XG5cbiAgYXdhaXQgY3JlYXRlU2Vzc2lvbigpO1xuICByZXR1cm4gdXNlcjtcbn1cbiJdfQ==