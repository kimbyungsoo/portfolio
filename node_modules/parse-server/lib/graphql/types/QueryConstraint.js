"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.BaseQuery = void 0;

var _graphql = require("graphql");

const supportedOperators = ['eq', 'ne', 'in', 'nin', 'exists', 'select', 'dontSelect'];

function description() {
  return `## Equal To:
  \`\`\`
  { key: "value" }
  { key: {eq: "value"} }
  \`\`\`
  
  ## Not Equal To
  \`\`\`
  { key: {ne: "value"} }
  \`\`\`
  
  ## Contained in:
  \`\`\`
  { key: {in: ["value1", "value2"]} }
  \`\`\`

  ## Not Contained in:
  \`\`\`
  { key: { nin: ["value1", "value2"] } }
  \`\`\`
  
  ## Exists: 
  \`\`\`
  { key: {exists: true} }
  \`\`\`
  
  ## Match results from another query
  ### This matches a value for a key in the result of a different query
  \`\`\`
  { key: {select: {"query": {"className":"Team","where":{"winPct":{"$gt":0.5}}},"key":"city"}}} }
  \`\`\`
  ### Requires that a keyâ€™s value not match a value for a key in the result of a different query
  \`\`\`
  { key: {dontSelect: {"query": {"className":"Team","where":{"winPct":{"$gt":0.5}}},"key":"city"}}} }
  \`\`\`
  `;
}

const parseFields = fields => {
  return fields.reduce((memo, field) => {
    const operator = field.name.value;

    if (supportedOperators.indexOf(operator) > -1) {
      const value = field.value.value;
      memo['$' + operator] = value;
    }

    return memo;
  }, {});
};

const parseLiteral = ast => {
  if (ast.kind == _graphql.Kind.OBJECT) {
    return parseFields(ast.fields);
  } else if (ast.kind == _graphql.Kind.STRING) {
    return ast.value;
  } else {
    throw 'Invalid literal for QueryConstraint';
  }
};

const BaseQuery = type => {
  return {
    eq: {
      type,
      description: 'Test for equality'
    },
    neq: {
      type,
      description: 'Test for non equality'
    },
    in: {
      type: new _graphql.GraphQLList(type),
      description: 'Test that the object is contained in'
    },
    nin: {
      type: new _graphql.GraphQLList(type)
    },
    exists: {
      type: _graphql.GraphQLBoolean
    }
  };
};

exports.BaseQuery = BaseQuery;
var _default = {
  description,
  parseLiteral,
  parseFields,
  BaseQuery
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ncmFwaHFsL3R5cGVzL1F1ZXJ5Q29uc3RyYWludC5qcyJdLCJuYW1lcyI6WyJzdXBwb3J0ZWRPcGVyYXRvcnMiLCJkZXNjcmlwdGlvbiIsInBhcnNlRmllbGRzIiwiZmllbGRzIiwicmVkdWNlIiwibWVtbyIsImZpZWxkIiwib3BlcmF0b3IiLCJuYW1lIiwidmFsdWUiLCJpbmRleE9mIiwicGFyc2VMaXRlcmFsIiwiYXN0Iiwia2luZCIsIktpbmQiLCJPQkpFQ1QiLCJTVFJJTkciLCJCYXNlUXVlcnkiLCJ0eXBlIiwiZXEiLCJuZXEiLCJpbiIsIkdyYXBoUUxMaXN0IiwibmluIiwiZXhpc3RzIiwiR3JhcGhRTEJvb2xlYW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFNQSxNQUFNQSxrQkFBa0IsR0FBRyxDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixLQUFuQixFQUEwQixRQUExQixFQUFvQyxRQUFwQyxFQUE4QyxZQUE5QyxDQUEzQjs7QUFFQSxTQUFTQyxXQUFULEdBQXVCO0FBQ3JCLFNBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBQVI7QUFvQ0Q7O0FBRUQsTUFBTUMsV0FBVyxHQUFJQyxNQUFELElBQVk7QUFDOUIsU0FBT0EsTUFBTSxDQUFDQyxNQUFQLENBQWMsQ0FBQ0MsSUFBRCxFQUFPQyxLQUFQLEtBQWlCO0FBQ3BDLFVBQU1DLFFBQVEsR0FBR0QsS0FBSyxDQUFDRSxJQUFOLENBQVdDLEtBQTVCOztBQUNBLFFBQUlULGtCQUFrQixDQUFDVSxPQUFuQixDQUEyQkgsUUFBM0IsSUFBdUMsQ0FBQyxDQUE1QyxFQUErQztBQUM3QyxZQUFNRSxLQUFLLEdBQUdILEtBQUssQ0FBQ0csS0FBTixDQUFZQSxLQUExQjtBQUNBSixNQUFBQSxJQUFJLENBQUMsTUFBTUUsUUFBUCxDQUFKLEdBQXVCRSxLQUF2QjtBQUNEOztBQUNELFdBQU9KLElBQVA7QUFDRCxHQVBNLEVBT0osRUFQSSxDQUFQO0FBUUQsQ0FURDs7QUFXQSxNQUFNTSxZQUFZLEdBQUlDLEdBQUQsSUFBUztBQUM1QixNQUFJQSxHQUFHLENBQUNDLElBQUosSUFBWUMsY0FBS0MsTUFBckIsRUFBNkI7QUFDM0IsV0FBT2IsV0FBVyxDQUFDVSxHQUFHLENBQUNULE1BQUwsQ0FBbEI7QUFDRCxHQUZELE1BRU8sSUFBSVMsR0FBRyxDQUFDQyxJQUFKLElBQVlDLGNBQUtFLE1BQXJCLEVBQTZCO0FBQ2xDLFdBQU9KLEdBQUcsQ0FBQ0gsS0FBWDtBQUNELEdBRk0sTUFFQTtBQUNMLFVBQU0scUNBQU47QUFDRDtBQUNGLENBUkQ7O0FBVU8sTUFBTVEsU0FBUyxHQUFJQyxJQUFELElBQVU7QUFDakMsU0FBTztBQUNMQyxJQUFBQSxFQUFFLEVBQUU7QUFDRkQsTUFBQUEsSUFERTtBQUVGakIsTUFBQUEsV0FBVyxFQUFFO0FBRlgsS0FEQztBQUtMbUIsSUFBQUEsR0FBRyxFQUFFO0FBQ0hGLE1BQUFBLElBREc7QUFFSGpCLE1BQUFBLFdBQVcsRUFBRTtBQUZWLEtBTEE7QUFTTG9CLElBQUFBLEVBQUUsRUFBRTtBQUNGSCxNQUFBQSxJQUFJLEVBQUUsSUFBSUksb0JBQUosQ0FBZ0JKLElBQWhCLENBREo7QUFFRmpCLE1BQUFBLFdBQVcsRUFBRTtBQUZYLEtBVEM7QUFhTHNCLElBQUFBLEdBQUcsRUFBRTtBQUNITCxNQUFBQSxJQUFJLEVBQUUsSUFBSUksb0JBQUosQ0FBZ0JKLElBQWhCO0FBREgsS0FiQTtBQWdCTE0sSUFBQUEsTUFBTSxFQUFFO0FBQ05OLE1BQUFBLElBQUksRUFBRU87QUFEQTtBQWhCSCxHQUFQO0FBb0JELENBckJNOzs7ZUF1QlE7QUFDYnhCLEVBQUFBLFdBRGE7QUFFYlUsRUFBQUEsWUFGYTtBQUdiVCxFQUFBQSxXQUhhO0FBSWJlLEVBQUFBO0FBSmEsQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEtpbmQsXG4gIEdyYXBoUUxMaXN0LFxuICBHcmFwaFFMQm9vbGVhblxufSBmcm9tICdncmFwaHFsJ1xuXG5jb25zdCBzdXBwb3J0ZWRPcGVyYXRvcnMgPSBbJ2VxJywgJ25lJywgJ2luJywgJ25pbicsICdleGlzdHMnLCAnc2VsZWN0JywgJ2RvbnRTZWxlY3QnXVxuXG5mdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgcmV0dXJuIGAjIyBFcXVhbCBUbzpcbiAgXFxgXFxgXFxgXG4gIHsga2V5OiBcInZhbHVlXCIgfVxuICB7IGtleToge2VxOiBcInZhbHVlXCJ9IH1cbiAgXFxgXFxgXFxgXG4gIFxuICAjIyBOb3QgRXF1YWwgVG9cbiAgXFxgXFxgXFxgXG4gIHsga2V5OiB7bmU6IFwidmFsdWVcIn0gfVxuICBcXGBcXGBcXGBcbiAgXG4gICMjIENvbnRhaW5lZCBpbjpcbiAgXFxgXFxgXFxgXG4gIHsga2V5OiB7aW46IFtcInZhbHVlMVwiLCBcInZhbHVlMlwiXX0gfVxuICBcXGBcXGBcXGBcblxuICAjIyBOb3QgQ29udGFpbmVkIGluOlxuICBcXGBcXGBcXGBcbiAgeyBrZXk6IHsgbmluOiBbXCJ2YWx1ZTFcIiwgXCJ2YWx1ZTJcIl0gfSB9XG4gIFxcYFxcYFxcYFxuICBcbiAgIyMgRXhpc3RzOiBcbiAgXFxgXFxgXFxgXG4gIHsga2V5OiB7ZXhpc3RzOiB0cnVlfSB9XG4gIFxcYFxcYFxcYFxuICBcbiAgIyMgTWF0Y2ggcmVzdWx0cyBmcm9tIGFub3RoZXIgcXVlcnlcbiAgIyMjIFRoaXMgbWF0Y2hlcyBhIHZhbHVlIGZvciBhIGtleSBpbiB0aGUgcmVzdWx0IG9mIGEgZGlmZmVyZW50IHF1ZXJ5XG4gIFxcYFxcYFxcYFxuICB7IGtleToge3NlbGVjdDoge1wicXVlcnlcIjoge1wiY2xhc3NOYW1lXCI6XCJUZWFtXCIsXCJ3aGVyZVwiOntcIndpblBjdFwiOntcIiRndFwiOjAuNX19fSxcImtleVwiOlwiY2l0eVwifX19IH1cbiAgXFxgXFxgXFxgXG4gICMjIyBSZXF1aXJlcyB0aGF0IGEga2V54oCZcyB2YWx1ZSBub3QgbWF0Y2ggYSB2YWx1ZSBmb3IgYSBrZXkgaW4gdGhlIHJlc3VsdCBvZiBhIGRpZmZlcmVudCBxdWVyeVxuICBcXGBcXGBcXGBcbiAgeyBrZXk6IHtkb250U2VsZWN0OiB7XCJxdWVyeVwiOiB7XCJjbGFzc05hbWVcIjpcIlRlYW1cIixcIndoZXJlXCI6e1wid2luUGN0XCI6e1wiJGd0XCI6MC41fX19LFwia2V5XCI6XCJjaXR5XCJ9fX0gfVxuICBcXGBcXGBcXGBcbiAgYDtcbn1cblxuY29uc3QgcGFyc2VGaWVsZHMgPSAoZmllbGRzKSA9PiB7XG4gIHJldHVybiBmaWVsZHMucmVkdWNlKChtZW1vLCBmaWVsZCkgPT4ge1xuICAgIGNvbnN0IG9wZXJhdG9yID0gZmllbGQubmFtZS52YWx1ZTtcbiAgICBpZiAoc3VwcG9ydGVkT3BlcmF0b3JzLmluZGV4T2Yob3BlcmF0b3IpID4gLTEpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQudmFsdWUudmFsdWU7XG4gICAgICBtZW1vWyckJyArIG9wZXJhdG9yXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbWVtbztcbiAgfSwge30pO1xufVxuXG5jb25zdCBwYXJzZUxpdGVyYWwgPSAoYXN0KSA9PiB7XG4gIGlmIChhc3Qua2luZCA9PSBLaW5kLk9CSkVDVCkge1xuICAgIHJldHVybiBwYXJzZUZpZWxkcyhhc3QuZmllbGRzKTtcbiAgfSBlbHNlIGlmIChhc3Qua2luZCA9PSBLaW5kLlNUUklORykge1xuICAgIHJldHVybiBhc3QudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgJ0ludmFsaWQgbGl0ZXJhbCBmb3IgUXVlcnlDb25zdHJhaW50JztcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IEJhc2VRdWVyeSA9ICh0eXBlKSA9PiB7XG4gIHJldHVybiB7XG4gICAgZXE6IHtcbiAgICAgIHR5cGUsXG4gICAgICBkZXNjcmlwdGlvbjogJ1Rlc3QgZm9yIGVxdWFsaXR5JyxcbiAgICB9LFxuICAgIG5lcToge1xuICAgICAgdHlwZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnVGVzdCBmb3Igbm9uIGVxdWFsaXR5JyxcbiAgICB9LFxuICAgIGluOiB7XG4gICAgICB0eXBlOiBuZXcgR3JhcGhRTExpc3QodHlwZSksXG4gICAgICBkZXNjcmlwdGlvbjogJ1Rlc3QgdGhhdCB0aGUgb2JqZWN0IGlzIGNvbnRhaW5lZCBpbicsXG4gICAgfSxcbiAgICBuaW46IHtcbiAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTGlzdCh0eXBlKSxcbiAgICB9LFxuICAgIGV4aXN0czoge1xuICAgICAgdHlwZTogR3JhcGhRTEJvb2xlYW4sXG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRlc2NyaXB0aW9uLFxuICBwYXJzZUxpdGVyYWwsXG4gIHBhcnNlRmllbGRzLFxuICBCYXNlUXVlcnksXG59XG4iXX0=