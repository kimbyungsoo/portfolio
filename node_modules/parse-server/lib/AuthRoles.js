"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AuthRoles = undefined;

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const Auth = require("./Auth").Auth;
const RestQuery = require('./RestQuery');
const Parse = require('parse/node');

// Operation results for role
const OppResult = Object.freeze({
  rejected: 0, // role rejected (no path to role was found valid)
  accepted: 1, // role accepted (at least one path to role was valid)
  processing: 2 // role is being validated (this prevents circular roles)
});

/**
 * Builds the role info object to be used.
 * @param {String} name the name of the role
 * @param {String} objectId the role id
 * @param {Set} parents the available paths for this role. (Parent Roles)
 * @param {OppResult} oppResult the role acl computation result
 */
const RoleInfo = (name, objectId, ACL, parents, oppResult = null) => ({
  name,
  objectId,
  ACL,
  parents,
  oppResult
});

class AuthRoles {
  /**
   * @param {Auth} masterAuth the Auth object performing the request
   * @param {String} userId the id of the user performing the request
   */
  constructor(masterAuth, user) {
    this.masterAuth = masterAuth;
    this.user = user;
    this.userId = user.id;
    // final list of accessible role names
    this.accessibleRoleNames = new Set();
    // Contains a relation between the role blocking and the roles that are blocked.
    // This will speedup things when we re-accept a previously rejected role.
    this.blockingRoles = { string: Set };
  }

  /**
   * Returns a promise that resolves with all 'accessibleRoleNames'.
   * @returns {Promise<Array>}
   */
  findRoles() {
    return this.findDirectRoles().then(roles => this.findRolesOfRoles(roles)).then(roleMap => this.computeAccess(roleMap)).then(() => Promise.resolve(Array.from(this.accessibleRoleNames)));
  }

  /**
   * Resolves with a promise once all direct roles are fetched.
   * Direct roles are roles the user is in the 'users' relation.
   * @returns {Promise<Array>} Array of Role objects fetched from db.
   */
  findDirectRoles() {
    var restWhere = { 'users': { __type: 'Pointer', className: '_User', objectId: this.userId } };
    return _performQuery(restWhere, this.masterAuth);
  }

  /**
   * Given a list of roles, find all the parent roles.
   * @param {Array} roles array of role objects fetched from db
   * @returns {Promise<RoleChildParentMap>} RoleChildParentMap
   */
  findRolesOfRoles(roles) {
    const map = {};
    const ids = new Set();

    // map the current roles we have
    _lodash2.default.forEach(roles, role => {
      const roleId = role.objectId;
      ids.add(roleId);
      map[roleId] = RoleInfo(role.name, role.objectId, role.ACL, new Set());
    });

    // the iterator we will use to loop through the ids from set
    const idsIterator = ids[Symbol.iterator]();
    return this._findAndBuildRolesForRolesRecursivelyOntoMap(idsIterator, ids, map, this.masterAuth);
  }

  /**
   * Iterates over each branch to resolve each role's accessibility.
   * Branch will be looped through from inside out, and each
   * node ACL will be validated for accessibility
   * ex: Roles are fetched in this order:
   *  Admins -> Collaborators -> Members
   * Iteration will occure in the opposite order:
   *  Admins <- Collaborators <- Members
   * @param {RoleChildParentMap} map our role map
   * @returns {Promise<void>}
   */
  computeAccess(map) {
    return new Promise(resolve => {
      _lodash2.default.forEach(map, role => {
        const roleResult = this.computeAccessOnRole(role, map);
        // do a bunch of stuff only when role is accepted.
        if (roleResult === OppResult.accepted) {
          // add to role name set.
          this.accessibleRoleNames.add("role:" + role.name);
          // solve previous role blames if any available.
          this.solveRoleRejectionBlamesIfAny(role, map);
        }
      });
      resolve();
    });
  }

  /**
   * Determins the role's accessibility status.
   * Both Statements should be true:
   * 1 - At least one path to role is accessible by this user
   * 2 - Role ACl is accesible by this user
   * @param {RoleChildParentMapItem} role the role to compute on
   * @param {RoleChildParentMap} rolesMap our role map
   * @returns {OppResult}
   */
  computeAccessOnRole(role, rolesMap) {
    const acl = role.ACL;
    // Dont bother checking if the ACL
    // is empty or corrupt
    if (acl === {} || !acl) {
      return OppResult.rejected;
    }
    // assume role is rejected
    var result = OppResult.rejected;
    if (role.result === OppResult.processing) {
      // This role(path) is currently being processed.
      // This mean that we stubled upon a circular path.
      // So we reject the role for now.
      // ex: R3* <- R2 <- R3* <- R1
      result = OppResult.rejected;
    } else if (role.result === OppResult.rejected) {
      result = OppResult.rejected;
    } else if (role.result === OppResult.accepted) {
      result = OppResult.accepted;
    } else {
      // mark processing
      role.result = OppResult.processing;
      // Paths are computed following 'or' logic
      // only one path to a role is sufficient to accept the role.
      // If no parents, the role is directly accessible, we just need
      // to check its ACL.
      var parentPathsResult = OppResult.accepted;
      if (role.parents.size > 0) {
        // check the paths that leads to this role using our Map.
        parentPathsResult = this.isAnyPathToRoleValid(role, rolesMap);
      }
      // if the parent's path is accepted or there
      // is no parent path. Lets check the role's ACL.
      if (parentPathsResult === OppResult.accepted) {
        if (this.isRoleAclAccessible(role) === true) {
          result = OppResult.accepted;
        } else {
          result = OppResult.rejected;
        }
      } else {
        result = parentPathsResult;
      }
    }

    role.result = result;
    return result;
  }

  /**
   * Determins if any of the role's paths (parents) is a valid path.
   * @param {RoleChildParentMapItem} role the role to compute on
   * @param {RoleChildParentMap} rolesMap our role map
   * @returns {OppResult} (Accepted | Rejected)
   */
  isAnyPathToRoleValid(role, rolesMap) {
    const parentIds = role.parents;
    const iterator = parentIds[Symbol.iterator]();
    const size = parentIds.size;
    // compute each path individually, and brake as soon
    // as we have a good one.
    for (let index = 0; index < size; index++) {
      const parentId = iterator.next().value;
      const parentRole = rolesMap[parentId];
      if (!parentRole) {
        continue;
      }
      // compute access on current parent path node like for any
      // other role normally.
      const pathResult = this.computeAccessOnRole(parentRole, rolesMap);
      if (pathResult === OppResult.accepted) {
        // path accepted, skip all other paths and return.
        // any previous rejection that were issued will be dealt with later.
        return OppResult.accepted;
      }
      // Mark our 'role' as rejected by 'parentRole'
      this.blameRoleForRejection(role, parentRole);
    }
    return OppResult.rejected;
  }

  /**
   * A role is accessible when any of the following statements is valid:
   * 1- Role is publicly accessible
   * 2- User is explicitly given access to the role
   * 3- Role has access to itself
   * 4- Role is accessible from other roles we have
   * @param {RoleChildParentMapItem} role the role to check.
   * @returns {Boolean} accessible or not
   */
  isRoleAclAccessible(role) {
    const acl = role.ACL;
    // (1)
    if (_isAclAccessibleFromRoleName(acl, "*")) {
      return true;
    }
    // (2)
    if (_isAclAccessibleFromRoleName(acl, this.userId)) {
      return true;
    }
    // (3)
    if (_isAclAccessibleFromRoleName(acl, `role:${role.name}`)) {
      return true;
    }
    // (4)
    if (_isAclAccessibleFromRoleNames(acl, this.accessibleRoleNames)) {
      return true;
    }
    return false;
  }

  /**
   * Adds relationship between the role that is blocking another role.
   * Usually Parent is blocking Child.
   * @param {RoleChildParentMapItem} roleThatWasRejected the role that was just rejected
   * @param {RoleChildParentMapItem} roleThatCausedTheRejection the role that caused this rejection
   */
  blameRoleForRejection(roleThatWasRejected, roleThatCausedTheRejection) {
    const roleThatCausedTheRejectionId = roleThatCausedTheRejection.objectId;
    const roleThatWasRejectedId = roleThatWasRejected.objectId;
    // other rejections from same role ?
    const otherRejections = this.blockingRoles[roleThatCausedTheRejectionId];
    if (otherRejections) {
      otherRejections.add(roleThatWasRejectedId);
    } else {
      this.blockingRoles[roleThatCausedTheRejectionId] = new Set([roleThatWasRejectedId]);
    }
  }

  /**
  * This will iterate over all roles that the 'roleThatWasSolved' is blocking and accept them if possible.
  * @param {RoleChildParentMapItem} roleThatWasSolved previous role that was blocked and may be blocking other roles too.
  */
  solveRoleRejectionBlamesIfAny(roleThatWasSolved, map) {
    const roleThatWasSolvedId = roleThatWasSolved.objectId;
    // Get previous rejections if any
    const previousRejections = this.blockingRoles[roleThatWasSolvedId];
    if (previousRejections) {
      // loop throught the roles and retry their access
      previousRejections.forEach(roleId => {
        const role = map[roleId];
        // is he still blocked ?
        if (role && role.result !== OppResult.accepted) {
          // is his acl accessible now ?
          if (this.isRoleAclAccessible(role)) {
            // accept role
            role.result = OppResult.accepted;
            this.accessibleRoleNames.add(role.name);
            // do the same fo that role
            this.solveRoleRejectionBlamesIfAny(role, map);
          }
        }
      });
    }
  }

  /**
   * Given a set of role Ids, will recursively find all parent roles.
   * @param {Iterator} idsIterator what is used to iterate over 'ids'
   * @param {Set} ids the set of role ids to iteratre on
   * @param {RoleChildParentMap} currentMapState our role map
   * @param {Auth} masterAuth
   * @returns {Promise}
   */
  _findAndBuildRolesForRolesRecursivelyOntoMap(idsIterator, ids, currentMapState, masterAuth) {
    // get the next id to operate on
    const parentRoleId = idsIterator.next().value;
    // no next id on iteration, we are done !
    if (!parentRoleId) {
      return Promise.resolve(currentMapState);
    }
    // build query and find Roles
    const restWhere = { 'roles': { __type: 'Pointer', className: '_Role', objectId: parentRoleId } };
    return _performQuery(restWhere, masterAuth).then(roles => {
      // map roles linking them to parent
      _lodash2.default.forEach(roles, role => {
        const childRoleId = role.objectId;
        // add to set to use it later on.
        // circular roles are cut since 'Set' will not add it.
        // So no role will be fetched twice.
        ids.add(childRoleId);
        // add to role map
        const roleMap = currentMapState[childRoleId];
        if (roleMap) {
          // we already have a parent for this role
          // lets add another one
          roleMap.parents.add(parentRoleId);
        } else {
          // new role
          currentMapState[childRoleId] = RoleInfo(role.name, childRoleId, role.ACL, new Set([parentRoleId]));
        }
      });
      // find the next ones
      return this._findAndBuildRolesForRolesRecursivelyOntoMap(idsIterator, ids, currentMapState, masterAuth);
    });
  }
}

exports.AuthRoles = AuthRoles; /**
                                * A helper method to return and execute the appropriate query.
                                * @param {Object} restWhere query constraints
                                * @param {Auth} masterAuth the master auth we will be using
                                */

const _performQuery = (restWhere = {}, masterAuth) => {
  if (masterAuth.config) {
    return new RestQuery(masterAuth.config, masterAuth, '_Role', restWhere, {}).execute().then(response => response.results);
  } else {
    const query = new Parse.Query(Parse.Role);
    _lodash2.default.forEach(restWhere, (value, key) => {
      query.equalTo(key, Parse.Object.fromJSON({
        className: value.className,
        objectId: value.objectId
      }));
      // failsafe for devs just to prevent fetching the wrong roles
      if (key !== 'users' && key !== 'roles') {
        throw 'Unsupported AuthRole query key: ' + key;
      }
    });
    return query.find({ useMasterKey: true }).then(results => results.map(obj => obj.toJSON()));
  }
};

/**
 * Checks if ACL grants access from a Set of roles.
 * Only one role is sufficient.
 * @param {Object} acl the acl to check
 * @param {Set} roleNames the role names to compute accessibility on 'acl'
 * @returns {Boolean}
 */
const _isAclAccessibleFromRoleNames = (acl, roleNames) => {
  var isNotAccessible = true;
  _lodash2.default.every(acl, (value, key) => {
    // match name from ACL Key
    if (roleNames.has(key)) {
      // brake when found
      isNotAccessible = !_isReadableAcl(value);
    }
    return isNotAccessible;
  });
  return !isNotAccessible;
};

/**
 * Checks if ACL grants access for a specific role name.
 * @param {Object} acl the acl to check
 * @param {String} roleName the role name to compute accessibility on 'acl'
 * @returns {Boolean}
 */
const _isAclAccessibleFromRoleName = (acl, roleName) => {
  const statement = acl[roleName];
  if (statement) {
    return _isReadableAcl(statement);
  }
  return false;
};

/**
 * Checks if acl statement is readable.
 * "read" is true
 * @returns {Boolean}
 */
const _isReadableAcl = statement => statement.read === true;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9BdXRoUm9sZXMuanMiXSwibmFtZXMiOlsiQXV0aCIsInJlcXVpcmUiLCJSZXN0UXVlcnkiLCJQYXJzZSIsIk9wcFJlc3VsdCIsIk9iamVjdCIsImZyZWV6ZSIsInJlamVjdGVkIiwiYWNjZXB0ZWQiLCJwcm9jZXNzaW5nIiwiUm9sZUluZm8iLCJuYW1lIiwib2JqZWN0SWQiLCJBQ0wiLCJwYXJlbnRzIiwib3BwUmVzdWx0IiwiQXV0aFJvbGVzIiwiY29uc3RydWN0b3IiLCJtYXN0ZXJBdXRoIiwidXNlciIsInVzZXJJZCIsImlkIiwiYWNjZXNzaWJsZVJvbGVOYW1lcyIsIlNldCIsImJsb2NraW5nUm9sZXMiLCJzdHJpbmciLCJmaW5kUm9sZXMiLCJmaW5kRGlyZWN0Um9sZXMiLCJ0aGVuIiwicm9sZXMiLCJmaW5kUm9sZXNPZlJvbGVzIiwicm9sZU1hcCIsImNvbXB1dGVBY2Nlc3MiLCJQcm9taXNlIiwicmVzb2x2ZSIsIkFycmF5IiwiZnJvbSIsInJlc3RXaGVyZSIsIl9fdHlwZSIsImNsYXNzTmFtZSIsIl9wZXJmb3JtUXVlcnkiLCJtYXAiLCJpZHMiLCJfIiwiZm9yRWFjaCIsInJvbGUiLCJyb2xlSWQiLCJhZGQiLCJpZHNJdGVyYXRvciIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX2ZpbmRBbmRCdWlsZFJvbGVzRm9yUm9sZXNSZWN1cnNpdmVseU9udG9NYXAiLCJyb2xlUmVzdWx0IiwiY29tcHV0ZUFjY2Vzc09uUm9sZSIsInNvbHZlUm9sZVJlamVjdGlvbkJsYW1lc0lmQW55Iiwicm9sZXNNYXAiLCJhY2wiLCJyZXN1bHQiLCJwYXJlbnRQYXRoc1Jlc3VsdCIsInNpemUiLCJpc0FueVBhdGhUb1JvbGVWYWxpZCIsImlzUm9sZUFjbEFjY2Vzc2libGUiLCJwYXJlbnRJZHMiLCJpbmRleCIsInBhcmVudElkIiwibmV4dCIsInZhbHVlIiwicGFyZW50Um9sZSIsInBhdGhSZXN1bHQiLCJibGFtZVJvbGVGb3JSZWplY3Rpb24iLCJfaXNBY2xBY2Nlc3NpYmxlRnJvbVJvbGVOYW1lIiwiX2lzQWNsQWNjZXNzaWJsZUZyb21Sb2xlTmFtZXMiLCJyb2xlVGhhdFdhc1JlamVjdGVkIiwicm9sZVRoYXRDYXVzZWRUaGVSZWplY3Rpb24iLCJyb2xlVGhhdENhdXNlZFRoZVJlamVjdGlvbklkIiwicm9sZVRoYXRXYXNSZWplY3RlZElkIiwib3RoZXJSZWplY3Rpb25zIiwicm9sZVRoYXRXYXNTb2x2ZWQiLCJyb2xlVGhhdFdhc1NvbHZlZElkIiwicHJldmlvdXNSZWplY3Rpb25zIiwiY3VycmVudE1hcFN0YXRlIiwicGFyZW50Um9sZUlkIiwiY2hpbGRSb2xlSWQiLCJjb25maWciLCJleGVjdXRlIiwicmVzcG9uc2UiLCJyZXN1bHRzIiwicXVlcnkiLCJRdWVyeSIsIlJvbGUiLCJrZXkiLCJlcXVhbFRvIiwiZnJvbUpTT04iLCJmaW5kIiwidXNlTWFzdGVyS2V5Iiwib2JqIiwidG9KU09OIiwicm9sZU5hbWVzIiwiaXNOb3RBY2Nlc3NpYmxlIiwiZXZlcnkiLCJoYXMiLCJfaXNSZWFkYWJsZUFjbCIsInJvbGVOYW1lIiwic3RhdGVtZW50IiwicmVhZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7Ozs7QUFDQSxNQUFNQSxPQUFPQyxRQUFRLFFBQVIsRUFBa0JELElBQS9CO0FBQ0EsTUFBTUUsWUFBWUQsUUFBUSxhQUFSLENBQWxCO0FBQ0EsTUFBTUUsUUFBUUYsUUFBUSxZQUFSLENBQWQ7O0FBS0E7QUFDQSxNQUFNRyxZQUFZQyxPQUFPQyxNQUFQLENBQWM7QUFDOUJDLFlBQVUsQ0FEb0IsRUFDWjtBQUNsQkMsWUFBVSxDQUZvQixFQUVaO0FBQ2xCQyxjQUFZLENBSGtCLENBR1o7QUFIWSxDQUFkLENBQWxCOztBQU1BOzs7Ozs7O0FBT0EsTUFBTUMsV0FBVyxDQUFDQyxJQUFELEVBQU9DLFFBQVAsRUFBaUJDLEdBQWpCLEVBQXNCQyxPQUF0QixFQUFvQ0MsWUFBWSxJQUFoRCxNQUEwRDtBQUN6RUosTUFEeUU7QUFFekVDLFVBRnlFO0FBR3pFQyxL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Q0FBSCxFQUFzQjtBQUNwQjtBQUNBUSx3QkFBa0IsQ0FBRUcsZUFBZW5DLEtBQWYsQ0FBcEI7QUFDRDtBQUNELFdBQU9nQyxlQUFQO0FBQ0QsR0FQRDtBQVFBLFNBQU8sQ0FBRUEsZUFBVDtBQUNELENBWEQ7O0FBYUE7Ozs7OztBQU1BLE1BQU01QiwrQkFBK0IsQ0FBQ2QsR0FBRCxFQUFNOEMsUUFBTixLQUE0QjtBQUMvRCxRQUFNQyxZQUFZL0MsSUFBSThDLFFBQUosQ0FBbEI7QUFDQSxNQUFHQyxTQUFILEVBQWE7QUFDWCxXQUFPRixlQUFlRSxTQUFmLENBQVA7QUFDRDtBQUNELFNBQU8sS0FBUDtBQUNELENBTkQ7O0FBUUE7Ozs7O0FBS0EsTUFBTUYsaUJBQWtCRSxTQUFELElBQXdCQSxVQUFVQyxJQUFWLEtBQW1CLElBQWxFIiwiZmlsZSI6IkF1dGhSb2xlcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAgXyBmcm9tIFwibG9kYXNoXCI7XG5jb25zdCBBdXRoID0gcmVxdWlyZShcIi4vQXV0aFwiKS5BdXRoO1xuY29uc3QgUmVzdFF1ZXJ5ID0gcmVxdWlyZSgnLi9SZXN0UXVlcnknKTtcbmNvbnN0IFBhcnNlID0gcmVxdWlyZSgncGFyc2Uvbm9kZScpO1xuXG5pbnRlcmZhY2UgUm9sZUNoaWxkUGFyZW50TWFwSXRlbSB7bmFtZTogU3RyaW5nLCBvYmplY3RJZDogU3RyaW5nLCBBQ0w6IE9iamVjdCwgcGFyZW50czogU2V0LCByZXN1bHQ6IE9wcFJlc3VsdH1cbmludGVyZmFjZSBSb2xlQ2hpbGRQYXJlbnRNYXAgeyBvYmplY3RJZDogUm9sZUNoaWxkUGFyZW50TWFwSXRlbSB9XG5cbi8vIE9wZXJhdGlvbiByZXN1bHRzIGZvciByb2xlXG5jb25zdCBPcHBSZXN1bHQgPSBPYmplY3QuZnJlZXplKHtcbiAgcmVqZWN0ZWQ6IDAsICAgICAgLy8gcm9sZSByZWplY3RlZCAobm8gcGF0aCB0byByb2xlIHdhcyBmb3VuZCB2YWxpZClcbiAgYWNjZXB0ZWQ6IDEsICAgICAgLy8gcm9sZSBhY2NlcHRlZCAoYXQgbGVhc3Qgb25lIHBhdGggdG8gcm9sZSB3YXMgdmFsaWQpXG4gIHByb2Nlc3Npbmc6IDIgICAgIC8vIHJvbGUgaXMgYmVpbmcgdmFsaWRhdGVkICh0aGlzIHByZXZlbnRzIGNpcmN1bGFyIHJvbGVzKVxufSk7XG5cbi8qKlxuICogQnVpbGRzIHRoZSByb2xlIGluZm8gb2JqZWN0IHRvIGJlIHVzZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgcm9sZVxuICogQHBhcmFtIHtTdHJpbmd9IG9iamVjdElkIHRoZSByb2xlIGlkXG4gKiBAcGFyYW0ge1NldH0gcGFyZW50cyB0aGUgYXZhaWxhYmxlIHBhdGhzIGZvciB0aGlzIHJvbGUuIChQYXJlbnQgUm9sZXMpXG4gKiBAcGFyYW0ge09wcFJlc3VsdH0gb3BwUmVzdWx0IHRoZSByb2xlIGFjbCBjb21wdXRhdGlvbiByZXN1bHRcbiAqL1xuY29uc3QgUm9sZUluZm8gPSAobmFtZSwgb2JqZWN0SWQsIEFDTCwgcGFyZW50czogU2V0LCBvcHBSZXN1bHQgPSBudWxsKSA9PiAoe1xuICBuYW1lLFxuICBvYmplY3RJZCxcbiAgQUNMLFxuICBwYXJlbnRzLFxuICBvcHBSZXN1bHRcbn0pO1xuXG5leHBvcnQgY2xhc3MgQXV0aFJvbGVzIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXV0aH0gbWFzdGVyQXV0aCB0aGUgQXV0aCBvYmplY3QgcGVyZm9ybWluZyB0aGUgcmVxdWVzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXNlcklkIHRoZSBpZCBvZiB0aGUgdXNlciBwZXJmb3JtaW5nIHRoZSByZXF1ZXN0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihtYXN0ZXJBdXRoOiBBdXRoLCB1c2VyOiBQYXJzZS5Vc2VyKXtcbiAgICB0aGlzLm1hc3RlckF1dGggPSBtYXN0ZXJBdXRoO1xuICAgIHRoaXMudXNlciA9IHVzZXI7XG4gICAgdGhpcy51c2VySWQgPSB1c2VyLmlkO1xuICAgIC8vIGZpbmFsIGxpc3Qgb2YgYWNjZXNzaWJsZSByb2xlIG5hbWVzXG4gICAgdGhpcy5hY2Nlc3NpYmxlUm9sZU5hbWVzID0gbmV3IFNldCgpO1xuICAgIC8vIENvbnRhaW5zIGEgcmVsYXRpb24gYmV0d2VlbiB0aGUgcm9sZSBibG9ja2luZyBhbmQgdGhlIHJvbGVzIHRoYXQgYXJlIGJsb2NrZWQuXG4gICAgLy8gVGhpcyB3aWxsIHNwZWVkdXAgdGhpbmdzIHdoZW4gd2UgcmUtYWNjZXB0IGEgcHJldmlvdXNseSByZWplY3RlZCByb2xlLlxuICAgIHRoaXMuYmxvY2tpbmdSb2xlcyA9IHsgc3RyaW5nOiBTZXQgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYWxsICdhY2Nlc3NpYmxlUm9sZU5hbWVzJy5cbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fVxuICAgKi9cbiAgZmluZFJvbGVzKCl7XG4gICAgcmV0dXJuIHRoaXMuZmluZERpcmVjdFJvbGVzKClcbiAgICAgIC50aGVuKChyb2xlcykgPT4gdGhpcy5maW5kUm9sZXNPZlJvbGVzKHJvbGVzKSlcbiAgICAgIC50aGVuKChyb2xlTWFwKSA9PiB0aGlzLmNvbXB1dGVBY2Nlc3Mocm9sZU1hcCkpXG4gICAgICAudGhlbigoKSA9PiBQcm9taXNlLnJlc29sdmUoQXJyYXkuZnJvbSh0aGlzLmFjY2Vzc2libGVSb2xlTmFtZXMpKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgd2l0aCBhIHByb21pc2Ugb25jZSBhbGwgZGlyZWN0IHJvbGVzIGFyZSBmZXRjaGVkLlxuICAgKiBEaXJlY3Qgcm9sZXMgYXJlIHJvbGVzIHRoZSB1c2VyIGlzIGluIHRoZSAndXNlcnMnIHJlbGF0aW9uLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59IEFycmF5IG9mIFJvbGUgb2JqZWN0cyBmZXRjaGVkIGZyb20gZGIuXG4gICAqL1xuICBmaW5kRGlyZWN0Um9sZXMoKTogUHJvbWlzZTxBcnJheT4ge1xuICAgIHZhciByZXN0V2hlcmUgPSB7ICd1c2Vycyc6IHsgIF9fdHlwZTogJ1BvaW50ZXInLCBjbGFzc05hbWU6ICdfVXNlcicsIG9iamVjdElkOiB0aGlzLnVzZXJJZCB9IH07XG4gICAgcmV0dXJuIF9wZXJmb3JtUXVlcnkocmVzdFdoZXJlLCB0aGlzLm1hc3RlckF1dGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgbGlzdCBvZiByb2xlcywgZmluZCBhbGwgdGhlIHBhcmVudCByb2xlcy5cbiAgICogQHBhcmFtIHtBcnJheX0gcm9sZXMgYXJyYXkgb2Ygcm9sZSBvYmplY3RzIGZldGNoZWQgZnJvbSBkYlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSb2xlQ2hpbGRQYXJlbnRNYXA+fSBSb2xlQ2hpbGRQYXJlbnRNYXBcbiAgICovXG4gIGZpbmRSb2xlc09mUm9sZXMocm9sZXMpOiBQcm9taXNlPFJvbGVDaGlsZFBhcmVudE1hcD57XG4gICAgY29uc3QgbWFwOiBSb2xlQ2hpbGRQYXJlbnRNYXAgPSB7fTtcbiAgICBjb25zdCBpZHM6IFNldCA9IG5ldyBTZXQoKTtcblxuICAgIC8vIG1hcCB0aGUgY3VycmVudCByb2xlcyB3ZSBoYXZlXG4gICAgXy5mb3JFYWNoKHJvbGVzLCByb2xlID0+IHtcbiAgICAgIGNvbnN0IHJvbGVJZCA9IHJvbGUub2JqZWN0SWQ7XG4gICAgICBpZHMuYWRkKHJvbGVJZCk7XG4gICAgICBtYXBbcm9sZUlkXSA9IFJvbGVJbmZvKHJvbGUubmFtZSwgcm9sZS5vYmplY3RJZCwgcm9sZS5BQ0wsIG5ldyBTZXQoKSk7XG4gICAgfSk7XG5cbiAgICAvLyB0aGUgaXRlcmF0b3Igd2Ugd2lsbCB1c2UgdG8gbG9vcCB0aHJvdWdoIHRoZSBpZHMgZnJvbSBzZXRcbiAgICBjb25zdCBpZHNJdGVyYXRvciA9IGlkc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRBbmRCdWlsZFJvbGVzRm9yUm9sZXNSZWN1cnNpdmVseU9udG9NYXAoaWRzSXRlcmF0b3IsIGlkcywgbWFwLCB0aGlzLm1hc3RlckF1dGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgZWFjaCBicmFuY2ggdG8gcmVzb2x2ZSBlYWNoIHJvbGUncyBhY2Nlc3NpYmlsaXR5LlxuICAgKiBCcmFuY2ggd2lsbCBiZSBsb29wZWQgdGhyb3VnaCBmcm9tIGluc2lkZSBvdXQsIGFuZCBlYWNoXG4gICAqIG5vZGUgQUNMIHdpbGwgYmUgdmFsaWRhdGVkIGZvciBhY2Nlc3NpYmlsaXR5XG4gICAqIGV4OiBSb2xlcyBhcmUgZmV0Y2hlZCBpbiB0aGlzIG9yZGVyOlxuICAgKiAgQWRtaW5zIC0+IENvbGxhYm9yYXRvcnMgLT4gTWVtYmVyc1xuICAgKiBJdGVyYXRpb24gd2lsbCBvY2N1cmUgaW4gdGhlIG9wcG9zaXRlIG9yZGVyOlxuICAgKiAgQWRtaW5zIDwtIENvbGxhYm9yYXRvcnMgPC0gTWVtYmVyc1xuICAgKiBAcGFyYW0ge1JvbGVDaGlsZFBhcmVudE1hcH0gbWFwIG91ciByb2xlIG1hcFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGNvbXB1dGVBY2Nlc3MobWFwOiBSb2xlQ2hpbGRQYXJlbnRNYXApOiBQcm9taXNlPHZvaWQ+e1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgXy5mb3JFYWNoKG1hcCwgKHJvbGUpID0+IHtcbiAgICAgICAgY29uc3Qgcm9sZVJlc3VsdDogT3BwUmVzdWx0ID0gdGhpcy5jb21wdXRlQWNjZXNzT25Sb2xlKHJvbGUsIG1hcCk7XG4gICAgICAgIC8vIGRvIGEgYnVuY2ggb2Ygc3R1ZmYgb25seSB3aGVuIHJvbGUgaXMgYWNjZXB0ZWQuXG4gICAgICAgIGlmKHJvbGVSZXN1bHQgPT09IE9wcFJlc3VsdC5hY2NlcHRlZCl7XG4gICAgICAgICAgLy8gYWRkIHRvIHJvbGUgbmFtZSBzZXQuXG4gICAgICAgICAgdGhpcy5hY2Nlc3NpYmxlUm9sZU5hbWVzLmFkZChcInJvbGU6XCIgKyByb2xlLm5hbWUpO1xuICAgICAgICAgIC8vIHNvbHZlIHByZXZpb3VzIHJvbGUgYmxhbWVzIGlmIGFueSBhdmFpbGFibGUuXG4gICAgICAgICAgdGhpcy5zb2x2ZVJvbGVSZWplY3Rpb25CbGFtZXNJZkFueShyb2xlLCBtYXApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbnMgdGhlIHJvbGUncyBhY2Nlc3NpYmlsaXR5IHN0YXR1cy5cbiAgICogQm90aCBTdGF0ZW1lbnRzIHNob3VsZCBiZSB0cnVlOlxuICAgKiAxIC0gQXQgbGVhc3Qgb25lIHBhdGggdG8gcm9sZSBpcyBhY2Nlc3NpYmxlIGJ5IHRoaXMgdXNlclxuICAgKiAyIC0gUm9sZSBBQ2wgaXMgYWNjZXNpYmxlIGJ5IHRoaXMgdXNlclxuICAgKiBAcGFyYW0ge1JvbGVDaGlsZFBhcmVudE1hcEl0ZW19IHJvbGUgdGhlIHJvbGUgdG8gY29tcHV0ZSBvblxuICAgKiBAcGFyYW0ge1JvbGVDaGlsZFBhcmVudE1hcH0gcm9sZXNNYXAgb3VyIHJvbGUgbWFwXG4gICAqIEByZXR1cm5zIHtPcHBSZXN1bHR9XG4gICAqL1xuICBjb21wdXRlQWNjZXNzT25Sb2xlKHJvbGU6IFJvbGVDaGlsZFBhcmVudE1hcEl0ZW0sIHJvbGVzTWFwOiBSb2xlQ2hpbGRQYXJlbnRNYXApOiBPcHBSZXN1bHR7XG4gICAgY29uc3QgYWNsID0gcm9sZS5BQ0w7XG4gICAgLy8gRG9udCBib3RoZXIgY2hlY2tpbmcgaWYgdGhlIEFDTFxuICAgIC8vIGlzIGVtcHR5IG9yIGNvcnJ1cHRcbiAgICBpZihhY2wgPT09IHt9IHx8ICFhY2wpe1xuICAgICAgcmV0dXJuIE9wcFJlc3VsdC5yZWplY3RlZDtcbiAgICB9XG4gICAgLy8gYXNzdW1lIHJvbGUgaXMgcmVqZWN0ZWRcbiAgICB2YXIgcmVzdWx0ID0gT3BwUmVzdWx0LnJlamVjdGVkO1xuICAgIGlmKHJvbGUucmVzdWx0ID09PSBPcHBSZXN1bHQucHJvY2Vzc2luZyl7XG4gICAgICAvLyBUaGlzIHJvbGUocGF0aCkgaXMgY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgIC8vIFRoaXMgbWVhbiB0aGF0IHdlIHN0dWJsZWQgdXBvbiBhIGNpcmN1bGFyIHBhdGguXG4gICAgICAvLyBTbyB3ZSByZWplY3QgdGhlIHJvbGUgZm9yIG5vdy5cbiAgICAgIC8vIGV4OiBSMyogPC0gUjIgPC0gUjMqIDwtIFIxXG4gICAgICByZXN1bHQgPSBPcHBSZXN1bHQucmVqZWN0ZWQ7XG4gICAgfWVsc2UgaWYocm9sZS5yZXN1bHQgPT09IE9wcFJlc3VsdC5yZWplY3RlZCl7XG4gICAgICByZXN1bHQgPSBPcHBSZXN1bHQucmVqZWN0ZWQ7XG4gICAgfWVsc2UgaWYocm9sZS5yZXN1bHQgPT09IE9wcFJlc3VsdC5hY2NlcHRlZCl7XG4gICAgICByZXN1bHQgPSBPcHBSZXN1bHQuYWNjZXB0ZWQ7XG4gICAgfWVsc2V7XG4gICAgICAvLyBtYXJrIHByb2Nlc3NpbmdcbiAgICAgIHJvbGUucmVzdWx0ID0gT3BwUmVzdWx0LnByb2Nlc3Npbmc7XG4gICAgICAvLyBQYXRocyBhcmUgY29tcHV0ZWQgZm9sbG93aW5nICdvcicgbG9naWNcbiAgICAgIC8vIG9ubHkgb25lIHBhdGggdG8gYSByb2xlIGlzIHN1ZmZpY2llbnQgdG8gYWNjZXB0IHRoZSByb2xlLlxuICAgICAgLy8gSWYgbm8gcGFyZW50cywgdGhlIHJvbGUgaXMgZGlyZWN0bHkgYWNjZXNzaWJsZSwgd2UganVzdCBuZWVkXG4gICAgICAvLyB0byBjaGVjayBpdHMgQUNMLlxuICAgICAgdmFyIHBhcmVudFBhdGhzUmVzdWx0ID0gT3BwUmVzdWx0LmFjY2VwdGVkO1xuICAgICAgaWYocm9sZS5wYXJlbnRzLnNpemUgPiAwKXtcbiAgICAgICAgLy8gY2hlY2sgdGhlIHBhdGhzIHRoYXQgbGVhZHMgdG8gdGhpcyByb2xlIHVzaW5nIG91ciBNYXAuXG4gICAgICAgIHBhcmVudFBhdGhzUmVzdWx0ID0gdGhpcy5pc0FueVBhdGhUb1JvbGVWYWxpZChyb2xlLCByb2xlc01hcCk7XG4gICAgICB9XG4gICAgICAvLyBpZiB0aGUgcGFyZW50J3MgcGF0aCBpcyBhY2NlcHRlZCBvciB0aGVyZVxuICAgICAgLy8gaXMgbm8gcGFyZW50IHBhdGguIExldHMgY2hlY2sgdGhlIHJvbGUncyBBQ0wuXG4gICAgICBpZihwYXJlbnRQYXRoc1Jlc3VsdCA9PT0gT3BwUmVzdWx0LmFjY2VwdGVkKXtcbiAgICAgICAgaWYodGhpcy5pc1JvbGVBY2xBY2Nlc3NpYmxlKHJvbGUpID09PSB0cnVlKXtcbiAgICAgICAgICByZXN1bHQgPSBPcHBSZXN1bHQuYWNjZXB0ZWQ7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHJlc3VsdCA9IE9wcFJlc3VsdC5yZWplY3RlZDtcbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIHJlc3VsdCA9IHBhcmVudFBhdGhzUmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJvbGUucmVzdWx0ID0gcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbnMgaWYgYW55IG9mIHRoZSByb2xlJ3MgcGF0aHMgKHBhcmVudHMpIGlzIGEgdmFsaWQgcGF0aC5cbiAgICogQHBhcmFtIHtSb2xlQ2hpbGRQYXJlbnRNYXBJdGVtfSByb2xlIHRoZSByb2xlIHRvIGNvbXB1dGUgb25cbiAgICogQHBhcmFtIHtSb2xlQ2hpbGRQYXJlbnRNYXB9IHJvbGVzTWFwIG91ciByb2xlIG1hcFxuICAgKiBAcmV0dXJucyB7T3BwUmVzdWx0fSAoQWNjZXB0ZWQgfCBSZWplY3RlZClcbiAgICovXG4gIGlzQW55UGF0aFRvUm9sZVZhbGlkKHJvbGU6IFJvbGVDaGlsZFBhcmVudE1hcEl0ZW0sIHJvbGVzTWFwOiBSb2xlQ2hpbGRQYXJlbnRNYXApOiBPcHBSZXN1bHR7XG4gICAgY29uc3QgcGFyZW50SWRzOiBTZXQgPSByb2xlLnBhcmVudHM7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBwYXJlbnRJZHNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IHNpemUgPSBwYXJlbnRJZHMuc2l6ZTtcbiAgICAvLyBjb21wdXRlIGVhY2ggcGF0aCBpbmRpdmlkdWFsbHksIGFuZCBicmFrZSBhcyBzb29uXG4gICAgLy8gYXMgd2UgaGF2ZSBhIGdvb2Qgb25lLlxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBzaXplOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBwYXJlbnRJZCA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgIGNvbnN0IHBhcmVudFJvbGUgPSByb2xlc01hcFtwYXJlbnRJZF07XG4gICAgICBpZighcGFyZW50Um9sZSl7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gY29tcHV0ZSBhY2Nlc3Mgb24gY3VycmVudCBwYXJlbnQgcGF0aCBub2RlIGxpa2UgZm9yIGFueVxuICAgICAgLy8gb3RoZXIgcm9sZSBub3JtYWxseS5cbiAgICAgIGNvbnN0IHBhdGhSZXN1bHQgPSB0aGlzLmNvbXB1dGVBY2Nlc3NPblJvbGUocGFyZW50Um9sZSwgcm9sZXNNYXApO1xuICAgICAgaWYocGF0aFJlc3VsdCA9PT0gT3BwUmVzdWx0LmFjY2VwdGVkKXtcbiAgICAgICAgLy8gcGF0aCBhY2NlcHRlZCwgc2tpcCBhbGwgb3RoZXIgcGF0aHMgYW5kIHJldHVybi5cbiAgICAgICAgLy8gYW55IHByZXZpb3VzIHJlamVjdGlvbiB0aGF0IHdlcmUgaXNzdWVkIHdpbGwgYmUgZGVhbHQgd2l0aCBsYXRlci5cbiAgICAgICAgcmV0dXJuIE9wcFJlc3VsdC5hY2NlcHRlZDtcbiAgICAgIH1cbiAgICAgIC8vIE1hcmsgb3VyICdyb2xlJyBhcyByZWplY3RlZCBieSAncGFyZW50Um9sZSdcbiAgICAgIHRoaXMuYmxhbWVSb2xlRm9yUmVqZWN0aW9uKHJvbGUsIHBhcmVudFJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gT3BwUmVzdWx0LnJlamVjdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgcm9sZSBpcyBhY2Nlc3NpYmxlIHdoZW4gYW55IG9mIHRoZSBmb2xsb3dpbmcgc3RhdGVtZW50cyBpcyB2YWxpZDpcbiAgICogMS0gUm9sZSBpcyBwdWJsaWNseSBhY2Nlc3NpYmxlXG4gICAqIDItIFVzZXIgaXMgZXhwbGljaXRseSBnaXZlbiBhY2Nlc3MgdG8gdGhlIHJvbGVcbiAgICogMy0gUm9sZSBoYXMgYWNjZXNzIHRvIGl0c2VsZlxuICAgKiA0LSBSb2xlIGlzIGFjY2Vzc2libGUgZnJvbSBvdGhlciByb2xlcyB3ZSBoYXZlXG4gICAqIEBwYXJhbSB7Um9sZUNoaWxkUGFyZW50TWFwSXRlbX0gcm9sZSB0aGUgcm9sZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IGFjY2Vzc2libGUgb3Igbm90XG4gICAqL1xuICBpc1JvbGVBY2xBY2Nlc3NpYmxlKHJvbGUpOiBib29sZWFue1xuICAgIGNvbnN0IGFjbCA9IHJvbGUuQUNMO1xuICAgIC8vICgxKVxuICAgIGlmKF9pc0FjbEFjY2Vzc2libGVGcm9tUm9sZU5hbWUoYWNsLCBcIipcIikpe1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vICgyKVxuICAgIGlmKF9pc0FjbEFjY2Vzc2libGVGcm9tUm9sZU5hbWUoYWNsLCB0aGlzLnVzZXJJZCkpe1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vICgzKVxuICAgIGlmKF9pc0FjbEFjY2Vzc2libGVGcm9tUm9sZU5hbWUoYWNsLCBgcm9sZToke3JvbGUubmFtZX1gKSl7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gKDQpXG4gICAgaWYoX2lzQWNsQWNjZXNzaWJsZUZyb21Sb2xlTmFtZXMoYWNsLCB0aGlzLmFjY2Vzc2libGVSb2xlTmFtZXMpKXtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGUgcm9sZSB0aGF0IGlzIGJsb2NraW5nIGFub3RoZXIgcm9sZS5cbiAgICogVXN1YWxseSBQYXJlbnQgaXMgYmxvY2tpbmcgQ2hpbGQuXG4gICAqIEBwYXJhbSB7Um9sZUNoaWxkUGFyZW50TWFwSXRlbX0gcm9sZVRoYXRXYXNSZWplY3RlZCB0aGUgcm9sZSB0aGF0IHdhcyBqdXN0IHJlamVjdGVkXG4gICAqIEBwYXJhbSB7Um9sZUNoaWxkUGFyZW50TWFwSXRlbX0gcm9sZVRoYXRDYXVzZWRUaGVSZWplY3Rpb24gdGhlIHJvbGUgdGhhdCBjYXVzZWQgdGhpcyByZWplY3Rpb25cbiAgICovXG4gIGJsYW1lUm9sZUZvclJlamVjdGlvbihyb2xlVGhhdFdhc1JlamVjdGVkLCByb2xlVGhhdENhdXNlZFRoZVJlamVjdGlvbik6IHZvaWR7XG4gICAgY29uc3Qgcm9sZVRoYXRDYXVzZWRUaGVSZWplY3Rpb25JZCA9IHJvbGVUaGF0Q2F1c2VkVGhlUmVqZWN0aW9uLm9iamVjdElkO1xuICAgIGNvbnN0IHJvbGVUaGF0V2FzUmVqZWN0ZWRJZCA9IHJvbGVUaGF0V2FzUmVqZWN0ZWQub2JqZWN0SWQ7XG4gICAgLy8gb3RoZXIgcmVqZWN0aW9ucyBmcm9tIHNhbWUgcm9sZSA/XG4gICAgY29uc3Qgb3RoZXJSZWplY3Rpb25zOiBTZXQgPSB0aGlzLmJsb2NraW5nUm9sZXNbcm9sZVRoYXRDYXVzZWRUaGVSZWplY3Rpb25JZF07XG4gICAgaWYob3RoZXJSZWplY3Rpb25zKXtcbiAgICAgIG90aGVyUmVqZWN0aW9ucy5hZGQocm9sZVRoYXRXYXNSZWplY3RlZElkKTtcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMuYmxvY2tpbmdSb2xlc1tyb2xlVGhhdENhdXNlZFRoZVJlamVjdGlvbklkXSA9IG5ldyBTZXQoW3JvbGVUaGF0V2FzUmVqZWN0ZWRJZF0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAqIFRoaXMgd2lsbCBpdGVyYXRlIG92ZXIgYWxsIHJvbGVzIHRoYXQgdGhlICdyb2xlVGhhdFdhc1NvbHZlZCcgaXMgYmxvY2tpbmcgYW5kIGFjY2VwdCB0aGVtIGlmIHBvc3NpYmxlLlxuICAqIEBwYXJhbSB7Um9sZUNoaWxkUGFyZW50TWFwSXRlbX0gcm9sZVRoYXRXYXNTb2x2ZWQgcHJldmlvdXMgcm9sZSB0aGF0IHdhcyBibG9ja2VkIGFuZCBtYXkgYmUgYmxvY2tpbmcgb3RoZXIgcm9sZXMgdG9vLlxuICAqL1xuICBzb2x2ZVJvbGVSZWplY3Rpb25CbGFtZXNJZkFueShyb2xlVGhhdFdhc1NvbHZlZDogUm9sZUNoaWxkUGFyZW50TWFwSXRlbSwgbWFwOiBSb2xlQ2hpbGRQYXJlbnRNYXApOiB2b2lke1xuICAgIGNvbnN0IHJvbGVUaGF0V2FzU29sdmVkSWQgPSByb2xlVGhhdFdhc1NvbHZlZC5vYmplY3RJZDtcbiAgICAvLyBHZXQgcHJldmlvdXMgcmVqZWN0aW9ucyBpZiBhbnlcbiAgICBjb25zdCBwcmV2aW91c1JlamVjdGlvbnM6IFNldCA9IHRoaXMuYmxvY2tpbmdSb2xlc1tyb2xlVGhhdFdhc1NvbHZlZElkXTtcbiAgICBpZihwcmV2aW91c1JlamVjdGlvbnMpe1xuICAgICAgLy8gbG9vcCB0aHJvdWdodCB0aGUgcm9sZXMgYW5kIHJldHJ5IHRoZWlyIGFjY2Vzc1xuICAgICAgcHJldmlvdXNSZWplY3Rpb25zLmZvckVhY2goKHJvbGVJZCkgPT4ge1xuICAgICAgICBjb25zdCByb2xlOiBSb2xlQ2hpbGRQYXJlbnRNYXBJdGVtID0gbWFwW3JvbGVJZF07XG4gICAgICAgIC8vIGlzIGhlIHN0aWxsIGJsb2NrZWQgP1xuICAgICAgICBpZihyb2xlICYmIHJvbGUucmVzdWx0ICE9PSBPcHBSZXN1bHQuYWNjZXB0ZWQpe1xuICAgICAgICAgIC8vIGlzIGhpcyBhY2wgYWNjZXNzaWJsZSBub3cgP1xuICAgICAgICAgIGlmKHRoaXMuaXNSb2xlQWNsQWNjZXNzaWJsZShyb2xlKSl7XG4gICAgICAgICAgICAvLyBhY2NlcHQgcm9sZVxuICAgICAgICAgICAgcm9sZS5yZXN1bHQgPSBPcHBSZXN1bHQuYWNjZXB0ZWQ7XG4gICAgICAgICAgICB0aGlzLmFjY2Vzc2libGVSb2xlTmFtZXMuYWRkKHJvbGUubmFtZSk7XG4gICAgICAgICAgICAvLyBkbyB0aGUgc2FtZSBmbyB0aGF0IHJvbGVcbiAgICAgICAgICAgIHRoaXMuc29sdmVSb2xlUmVqZWN0aW9uQmxhbWVzSWZBbnkocm9sZSwgbWFwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIHNldCBvZiByb2xlIElkcywgd2lsbCByZWN1cnNpdmVseSBmaW5kIGFsbCBwYXJlbnQgcm9sZXMuXG4gICAqIEBwYXJhbSB7SXRlcmF0b3J9IGlkc0l0ZXJhdG9yIHdoYXQgaXMgdXNlZCB0byBpdGVyYXRlIG92ZXIgJ2lkcydcbiAgICogQHBhcmFtIHtTZXR9IGlkcyB0aGUgc2V0IG9mIHJvbGUgaWRzIHRvIGl0ZXJhdHJlIG9uXG4gICAqIEBwYXJhbSB7Um9sZUNoaWxkUGFyZW50TWFwfSBjdXJyZW50TWFwU3RhdGUgb3VyIHJvbGUgbWFwXG4gICAqIEBwYXJhbSB7QXV0aH0gbWFzdGVyQXV0aFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIF9maW5kQW5kQnVpbGRSb2xlc0ZvclJvbGVzUmVjdXJzaXZlbHlPbnRvTWFwKGlkc0l0ZXJhdG9yLCBpZHM6IFNldCwgY3VycmVudE1hcFN0YXRlOiBSb2xlQ2hpbGRQYXJlbnRNYXAsIG1hc3RlckF1dGg6IEF1dGgpOiBQcm9taXNle1xuICAgIC8vIGdldCB0aGUgbmV4dCBpZCB0byBvcGVyYXRlIG9uXG4gICAgY29uc3QgcGFyZW50Um9sZUlkID0gaWRzSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgIC8vIG5vIG5leHQgaWQgb24gaXRlcmF0aW9uLCB3ZSBhcmUgZG9uZSAhXG4gICAgaWYoIXBhcmVudFJvbGVJZCl7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGN1cnJlbnRNYXBTdGF0ZSk7XG4gICAgfVxuICAgIC8vIGJ1aWxkIHF1ZXJ5IGFuZCBmaW5kIFJvbGVzXG4gICAgY29uc3QgcmVzdFdoZXJlID0geyAncm9sZXMnOiB7ICBfX3R5cGU6ICdQb2ludGVyJywgY2xhc3NOYW1lOiAnX1JvbGUnLCBvYmplY3RJZDogcGFyZW50Um9sZUlkIH0gfTtcbiAgICByZXR1cm4gX3BlcmZvcm1RdWVyeShyZXN0V2hlcmUsIG1hc3RlckF1dGgpXG4gICAgICAudGhlbigocm9sZXMpID0+IHtcbiAgICAgICAgLy8gbWFwIHJvbGVzIGxpbmtpbmcgdGhlbSB0byBwYXJlbnRcbiAgICAgICAgXy5mb3JFYWNoKHJvbGVzLCByb2xlID0+IHtcbiAgICAgICAgICBjb25zdCBjaGlsZFJvbGVJZCA9IHJvbGUub2JqZWN0SWQ7XG4gICAgICAgICAgLy8gYWRkIHRvIHNldCB0byB1c2UgaXQgbGF0ZXIgb24uXG4gICAgICAgICAgLy8gY2lyY3VsYXIgcm9sZXMgYXJlIGN1dCBzaW5jZSAnU2V0JyB3aWxsIG5vdCBhZGQgaXQuXG4gICAgICAgICAgLy8gU28gbm8gcm9sZSB3aWxsIGJlIGZldGNoZWQgdHdpY2UuXG4gICAgICAgICAgaWRzLmFkZChjaGlsZFJvbGVJZCk7XG4gICAgICAgICAgLy8gYWRkIHRvIHJvbGUgbWFwXG4gICAgICAgICAgY29uc3Qgcm9sZU1hcDogUm9sZUNoaWxkUGFyZW50TWFwSXRlbSA9IGN1cnJlbnRNYXBTdGF0ZVtjaGlsZFJvbGVJZF07XG4gICAgICAgICAgaWYocm9sZU1hcCl7XG4gICAgICAgICAgICAvLyB3ZSBhbHJlYWR5IGhhdmUgYSBwYXJlbnQgZm9yIHRoaXMgcm9sZVxuICAgICAgICAgICAgLy8gbGV0cyBhZGQgYW5vdGhlciBvbmVcbiAgICAgICAgICAgIHJvbGVNYXAucGFyZW50cy5hZGQocGFyZW50Um9sZUlkKTtcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIC8vIG5ldyByb2xlXG4gICAgICAgICAgICBjdXJyZW50TWFwU3RhdGVbY2hpbGRSb2xlSWRdID0gUm9sZUluZm8ocm9sZS5uYW1lLCBjaGlsZFJvbGVJZCwgcm9sZS5BQ0wsIG5ldyBTZXQoW3BhcmVudFJvbGVJZF0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBmaW5kIHRoZSBuZXh0IG9uZXNcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRBbmRCdWlsZFJvbGVzRm9yUm9sZXNSZWN1cnNpdmVseU9udG9NYXAoaWRzSXRlcmF0b3IsIGlkcywgY3VycmVudE1hcFN0YXRlLCBtYXN0ZXJBdXRoKTtcbiAgICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQSBoZWxwZXIgbWV0aG9kIHRvIHJldHVybiBhbmQgZXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgcXVlcnkuXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzdFdoZXJlIHF1ZXJ5IGNvbnN0cmFpbnRzXG4gKiBAcGFyYW0ge0F1dGh9IG1hc3RlckF1dGggdGhlIG1hc3RlciBhdXRoIHdlIHdpbGwgYmUgdXNpbmdcbiAqL1xuY29uc3QgX3BlcmZvcm1RdWVyeSA9IChyZXN0V2hlcmUgPSB7fSwgbWFzdGVyQXV0aDogQXV0aCk6IFJlc3RRdWVyeSA9PiB7XG4gIGlmKG1hc3RlckF1dGguY29uZmlnKXtcbiAgICByZXR1cm4gbmV3IFJlc3RRdWVyeShtYXN0ZXJBdXRoLmNvbmZpZywgbWFzdGVyQXV0aCwgJ19Sb2xlJywgcmVzdFdoZXJlLCB7fSlcbiAgICAgIC5leGVjdXRlKClcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLnJlc3VsdHMpO1xuICB9ZWxzZXtcbiAgICBjb25zdCBxdWVyeSA9IG5ldyBQYXJzZS5RdWVyeShQYXJzZS5Sb2xlKTtcbiAgICBfLmZvckVhY2gocmVzdFdoZXJlLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgcXVlcnkuZXF1YWxUbyhrZXksIFBhcnNlLk9iamVjdC5mcm9tSlNPTih7XG4gICAgICAgIGNsYXNzTmFtZTogdmFsdWUuY2xhc3NOYW1lLFxuICAgICAgICBvYmplY3RJZDogdmFsdWUub2JqZWN0SWRcbiAgICAgIH0pKTtcbiAgICAgIC8vIGZhaWxzYWZlIGZvciBkZXZzIGp1c3QgdG8gcHJldmVudCBmZXRjaGluZyB0aGUgd3Jvbmcgcm9sZXNcbiAgICAgIGlmKGtleSAhPT0gJ3VzZXJzJyAmJiBrZXkgIT09ICdyb2xlcycpe1xuICAgICAgICB0aHJvdyAnVW5zdXBwb3J0ZWQgQXV0aFJvbGUgcXVlcnkga2V5OiAnICsga2V5O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBxdWVyeS5maW5kKHsgdXNlTWFzdGVyS2V5OiB0cnVlIH0pXG4gICAgICAudGhlbigocmVzdWx0cykgPT4gcmVzdWx0cy5tYXAoKG9iaikgPT4gb2JqLnRvSlNPTigpKSlcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiBBQ0wgZ3JhbnRzIGFjY2VzcyBmcm9tIGEgU2V0IG9mIHJvbGVzLlxuICogT25seSBvbmUgcm9sZSBpcyBzdWZmaWNpZW50LlxuICogQHBhcmFtIHtPYmplY3R9IGFjbCB0aGUgYWNsIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1NldH0gcm9sZU5hbWVzIHRoZSByb2xlIG5hbWVzIHRvIGNvbXB1dGUgYWNjZXNzaWJpbGl0eSBvbiAnYWNsJ1xuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmNvbnN0IF9pc0FjbEFjY2Vzc2libGVGcm9tUm9sZU5hbWVzID0gKGFjbCwgcm9sZU5hbWVzOiBTZXQpOiBCb29sZWFuID0+IHtcbiAgdmFyIGlzTm90QWNjZXNzaWJsZSA9IHRydWU7XG4gIF8uZXZlcnkoYWNsLCAodmFsdWUsIGtleSkgPT4ge1xuICAgIC8vIG1hdGNoIG5hbWUgZnJvbSBBQ0wgS2V5XG4gICAgaWYocm9sZU5hbWVzLmhhcyhrZXkpKXtcbiAgICAgIC8vIGJyYWtlIHdoZW4gZm91bmRcbiAgICAgIGlzTm90QWNjZXNzaWJsZSA9ICEoX2lzUmVhZGFibGVBY2wodmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzTm90QWNjZXNzaWJsZTtcbiAgfSlcbiAgcmV0dXJuICEoaXNOb3RBY2Nlc3NpYmxlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgQUNMIGdyYW50cyBhY2Nlc3MgZm9yIGEgc3BlY2lmaWMgcm9sZSBuYW1lLlxuICogQHBhcmFtIHtPYmplY3R9IGFjbCB0aGUgYWNsIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gcm9sZU5hbWUgdGhlIHJvbGUgbmFtZSB0byBjb21wdXRlIGFjY2Vzc2liaWxpdHkgb24gJ2FjbCdcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5jb25zdCBfaXNBY2xBY2Nlc3NpYmxlRnJvbVJvbGVOYW1lID0gKGFjbCwgcm9sZU5hbWUpOiBCb29sZWFuID0+IHtcbiAgY29uc3Qgc3RhdGVtZW50ID0gYWNsW3JvbGVOYW1lXTtcbiAgaWYoc3RhdGVtZW50KXtcbiAgICByZXR1cm4gX2lzUmVhZGFibGVBY2woc3RhdGVtZW50KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFjbCBzdGF0ZW1lbnQgaXMgcmVhZGFibGUuXG4gKiBcInJlYWRcIiBpcyB0cnVlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuY29uc3QgX2lzUmVhZGFibGVBY2wgPSAoc3RhdGVtZW50KTogQm9vbGVhbiA9PiBzdGF0ZW1lbnQucmVhZCA9PT0gdHJ1ZTtcbiJdfQ==